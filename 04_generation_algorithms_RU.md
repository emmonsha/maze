# Алгоритмы генерации лабиринтов

## Обзор

Генерация лабиринтов - это процесс создания лабиринта, который является "совершенным" - то есть он имеет ровно один путь между любыми двумя точками, без петель и без изолированных областей. Это руководство охватывает алгоритм Эллера, который является одним из наиболее эффективных алгоритмов для генерации совершенных лабиринтов.

## Алгоритм Эллера

Алгоритм Эллера - это алгоритм генерации лабиринтов построчно, который обеспечивает совершенство лабиринта благодаря поддержанию определенных свойств множеств на протяжении всего процесса генерации.

### Ключевые концепции

1. **Множества**: Каждая ячейка в текущем ряду принадлежит множеству
2. **Горизонтальные соединения**: Объединяют соседние ячейки в одном ряду, которые находятся в разных множествах
3. **Вертикальные соединения**: Соединяют вниз для обеспечения хотя бы одного соединения каждого множества
4. **Финальный ряд**: Объединяют все оставшиеся множества для завершения лабиринта

### Шаги алгоритма

#### Шаг 1: Инициализация множеств
Каждая ячейка в первом ряду начинает в своем собственном множестве (идентифицируется по ее индексу столбца).

#### Шаг 2: Обработка каждого ряда
Для каждого ряда в лабиринте:
1. **Объединение по горизонтали**: Случайно объединяют соседние ячейки в том же ряду, если они находятся в разных множествах
2. **Соединение по вертикали**: Для каждого множества обеспечивают хотя бы одно соединение вниз к следующему ряду
3. **Подготовка следующего ряда**: Инициализируют множества для следующего ряда

#### Шаг 3: Финальный ряд
В последнем ряду объединяют все ячейки, которые все еще находятся в разных множествах.

## Реализация

### Основная структура

```python
def generate_eller_maze(rows: int, cols: int) -> Maze:
    """Сгенерировать совершенный лабиринт с использованием алгоритма Эллера."""
    maze = Maze(rows, cols)
    
    # Каждая ячейка в текущем ряду начинает в своем собственном множестве
    cell_sets = list(range(cols))  # [0, 1, 2, ..., cols-1]
    
    for row in range(rows):
        # Шаг 1: Объединить соседние ячейки по горизонтали (случайно)
        for col in range(cols - 1):
            set1, set2 = cell_sets[col], cell_sets[col + 1]
            
            # Объединять только если в разных множествах (чтобы предотвратить петли)
            if set1 != set2 and random.random() < 0.5:
                # Убрать стену между (row, col) и (row, col+1)
                maze.vertical_walls[row][col + 1] = False
                
                # Объединение: объединить множество set2 в множество set1
                old_set_id = set2
                new_set_id = set1
                for c in range(cols):
                    if cell_sets[c] == old_set_id:
                        cell_sets[c] = new_set_id

        # Шаг 2: Добавить вертикальные соединения к следующему ряду (кроме последнего ряда) / Шаг 2: Добавить Вертикальные Соединения к Следующему Ряду (Кроме Последнего Ряда)
        if row < rows - 1:
            # Сгруппировать ячейки по их множеству / Сгруппировать Ячейки По Их Множеству
            sets_dict = {}
            for col in range(cols):
                set_id = cell_sets[col]
                if set_id not in sets_dict:
                    sets_dict[set_id] = []
                sets_dict[set_id].append(col)
            
            # Для каждого множества соединить хотя бы одну ячейку вниз
            for set_id, cells_in_set in sets_dict.items():
                # Соединить хотя бы одну ячейку из каждого множества (случайное количество)
                num_connections = random.randint(1, len(cells_in_set))
                cells_to_connect = random.sample(cells_in_set, num_connections)
                
                for col in cells_to_connect:
                    # Убрать стену между (row, col) и (row+1, col)
                    maze.horizontal_walls[row + 1][col] = False
            
            # Подготовить множества для следующего ряда
            # Ячейки, которые соединились вниз, сохраняют тот же идентификатор множества
            next_row_sets = list(range(cols))  # Изначально каждая ячейка в следующем ряду в своем собственном множестве
            for col in range(cols):
                # Если мы соединились вниз от текущей ячейки, ячейка ниже получает тот же идентификатор множества
                if not maze.horizontal_walls[row + 1][col]:  # Если нет стены, значит было соединение вниз
                    next_row_sets[col] = cell_sets[col]
            
            cell_sets = next_row_sets
        else:
            # Шаг 3: Финальный ряд - объединить все оставшиеся множества
            for col in range(cols - 1):
                set1, set2 = cell_sets[col], cell_sets[col + 1]
                if set1 != set2:
                    # Объединить разные множества - убрать стену
                    maze.vertical_walls[rows - 1][col + 1] = False
                    
                    # Объединение: объединить множество set2 в множество set1
                    old_set_id = set2
                    new_set_id = set1
                    for c in range(cols):
                        if cell_sets[c] == old_set_id:
                            cell_sets[c] = new_set_id
    
    return maze
```

## Почему алгоритм Эллера работает

### Свойства совершенного лабиринта

1. **Связность**: Каждое множество имеет хотя бы одно соединение вниз, обеспечивая достижимость всех ячеек
2. **Отсутствие петель**: Горизонтальные соединения происходят только между разными множествами, предотвращая петли
3. **Полнота**: Финальный ряд объединяет все оставшиеся множества, обеспечивая полную связность лабиринта

### Эффективность по памяти

Алгоритм Эллера нуждается только в запоминании информации о множествах текущего ряда, что делает его эффективным по памяти с O(w) пространственной сложностью (где w - ширина/столбцы лабиринта).

## Другие алгоритмы генерации

### Рекурсивный бэктрекинг
- Использует подход DFS / Использует Подход DFS
- Создает длинные проходы с меньшим количеством тупиков
- Хорош для лабиринтов с более "естественным" видом

### Алгоритм Краскала
- Использует структуру данных Union-Find
- Рассматривает все возможные стены сразу
- Производит лабиринты с множеством коротких тупиков

### Алгоритм Прима
- Рандомизированная версия алгоритма минимального остовного дерева
- Создает лабиринты с множеством коротких проходов

## Сравнение алгоритмов

| Алгоритм | Память | Характеристики |
|----------|--------|---------------|
| Эллер | O(w) | Построчно, хороший баланс |
| Рекурсивный бэктрекинг | O(w×h) | Длинные проходы |
| Краскал | O(w×h) | Много коротких тупиков |
| Прим | O(w×h) | Много коротких проходов |

## Практические советы по реализации

1. **Рандомизация**: Использовать соответствующую рандомизацию, чтобы избежать предсказуемых паттернов
2. **Управление множествами**: Эффективные операции объединения множеств критичны для производительности
3. **Обработка границ**: Всегда обеспечивать, чтобы стены границ оставались целыми
4. **Валидация**: Проверять, что сгенерированные лабиринты действительно совершенные

Алгоритм Эллера особенно хорошо подходит для этого проекта благодаря своей эффективности по памяти и способности генерировать совершенные лабиринты построчно.